'use strict';

exports.__esModule = true;
exports.prune = prune;
exports.verifyDMP = verifyDMP;
exports.buildPackRef = buildPackRef;
exports.verifyPackRef = verifyPackRef;
exports.determinePackLinkSrcDst = determinePackLinkSrcDst;

var _fsExtraPromise = require('fs-extra-promise');

var _fsExtraPromise2 = _interopRequireDefault(_fsExtraPromise);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _rxjs = require('rxjs');

var _format = require('./util/format');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _ref(acc, dnv_PR) {
  return _ramda2['default'].append(dnv_PR, acc);
}

function _ref2(flatDMR) {
  return _ramda2['default'].fromPairs(flatDMR);
}

function prune(config, dnvPR) {
  // return obs of new dnvPR object
  return _rxjs.Observable.from(_ramda2['default'].toPairs(dnvPR) // [dnv, arrPackRef]
  ).mergeMap(function (dnv_PR) {
    return verifyDMP(dnv_PR, config);
  }).reduce(_ref, []).map(_ref2);
}

function _ref4(acc, packRef) {
  return _ramda2['default'].append(packRef, acc);
}

function _ref5(arrRefEI) {
  return arrRefEI.length;
}

function verifyDMP(_ref3, config) {
  var dnv = _ref3[0],
      arrPackRef = _ref3[1];
  // return obs of valid dnv_PR
  var concurrentOps = config.concurrentOps;

  return _rxjs.Observable.from(arrPackRef) // obs of packRefs
  // returns obs of valid packRef
  .mergeMap(function (packRef) {
    return verifyPackRef(dnv, packRef, false);
  }, concurrentOps).reduce(_ref4, []).filter(_ref5).map(function (arrRefEI) {
    return [dnv, arrRefEI];
  }); // dnv_PR
}

function buildPackRef(modFullPath, packageJsonInode, packageJsonMTimeEpoch) {
  return [modFullPath, packageJsonInode, packageJsonMTimeEpoch];
}

function _ref6(err) {
  if (err.code !== 'ENOENT') {
    console.error(err);
  }
}

function _ref7(x) {
  return x;
}

function verifyPackRef(dnv, packRef) {
  var returnEI = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // return obs of valid packRef
  var modDir = packRef[0];
  var packInode = packRef[1];
  var packMTimeEpoch = packRef[2];
  var packPath = _path2['default'].join(modDir, 'package.json');
  var packStat = void 0;
  return _rxjs.Observable.from(_fsExtraPromise2['default'].statAsync(packPath).then(function (stat) {
    // eslint-disable-line consistent-return
    if (stat && stat.ino === packInode && stat.mtime.getTime() === packMTimeEpoch) {
      packStat = stat; // save for later use
      return _fsExtraPromise2['default'].readJsonAsync(packPath, { throws: false });
    }
  })
  // if json and matches, return packRef or EI
  .then(function (json) {
    // eslint-disable-line consistent-return
    if (json) {
      var devNameVer = (0, _format.formatDevNameVersion)(packStat.dev, json.name, json.version);
      if (devNameVer === dnv) {
        return returnEI ? { // masterEI
          stat: packStat,
          fullParentDir: modDir
        } : packRef;
      }
    }
  })['catch'](_ref6)).filter(_ref7); // filter any undefineds, those were invalid
}

var masterEICache = {};

function checkMasterCache(config, rtenv, dnv, packEI) {
  // ret obs of masterEI
  var masterEI = masterEICache[dnv];
  if (masterEI) {
    if (!masterEI.then) {
      // it is not a promise
      return _rxjs.Observable.of(masterEI);
    }
    // otherwise it was a promise
    return _rxjs.Observable.fromPromise(masterEI);
  }
  // otherwise not found
  var masterEIProm = findExistingMaster(config, rtenv, dnv, packEI);
  masterEICache[dnv] = masterEIProm;
  // optimize future requests so they don't need to hit promise
  masterEIProm.then(function (masterEI) {
    masterEICache[dnv] = masterEI; // eliminate promise overhead
  });
  return _rxjs.Observable.fromPromise(masterEIProm);
}

function determinePackLinkSrcDst(config, rtenv, destEIdn) {
  // ret obs of srcDstObj
  if (rtenv.cancelled) {
    return _rxjs.Observable.empty();
  }
  var dstEI = destEIdn.entryInfo,
      dnv = destEIdn.devNameVer;


  return checkMasterCache(config, rtenv, dnv, dstEI).takeWhile(function () {
    return !rtenv.cancelled;
  }).filter(function (masterEI) {
    return !isEISameInode(masterEI, dstEI);
  }).map(function (masterEI) {
    return {
      devNameVer: dnv, // device:nameVersion
      src: masterEI.fullParentDir,
      srcPackInode: masterEI.stat.ino,
      srcPackMTimeEpoch: masterEI.stat.mtime.getTime(),
      dst: dstEI.fullParentDir,
      dstPackInode: dstEI.stat.ino,
      dstPackMTimeEpoch: dstEI.stat.mtime.getTime()
    };
  });
}

function isEISameInode(firstEI, secondEI) {
  return firstEI.stat.dev === secondEI.stat.dev && firstEI.stat.ino === secondEI.stat.ino;
}

// prepare for this to be async
function getExistingPackRefs(config, rtenv, dnv) {
  // returns observable to arrPackRefs
  // check rtenv.existingPackRefs[dnv] for ref tuples
  var masterPackRefs = _ramda2['default'].pathOr([], [dnv], rtenv.existingPackRefs); // array of [modDir, packInode, packMTimeEpoch] packRef tuples
  return _rxjs.Observable.of(masterPackRefs);
}

function _ref9(masterEI) {
  return masterEI;
}

function _ref10(masterEI, idx) {
  return [masterEI, idx];
}

function findExistingMaster(config, rtenv, dnv, ei) {
  function _ref8(packRef) {
    return verifyPackRef(dnv, packRef, true);
  }

  // returns promise resolving to masterEI
  /*
     we will be checking through the rtenv.existingPackRefs[dnv] packRefs
     to see if any are still valid. Resolve with the first one that is
     still valid, also returning the remaining packRefs. Not all of the
     packRefs will have been checked, just enough to find one valid one.
     A new array of refs will be updated in rtenv.updatedPackRefs
     which will omit any found to be invalid.
     Resolves with masterEI or uses ei provided
   */
  return getExistingPackRefs(config, rtenv, dnv).mergeMap(function (masterPackRefs) {
    if (!masterPackRefs.length) {
      // no valid found, set to empty []
      rtenv.updatedPackRefs[dnv] = [buildPackRef(ei.fullParentDir, ei.stat.ino, ei.stat.mtime.getTime())];
      return _rxjs.Observable.of(ei);
    }
    // otherwise we have packrefs check them
    return _rxjs.Observable.from(masterPackRefs).mergeMap(_ref8, 1 // one at a time since only need first
    ).first(_ref9, // exists
    _ref10, false).map(function (masterEI_idx) {
      if (!masterEI_idx) {
        // no valid found, set to empty []
        rtenv.updatedPackRefs[dnv] = [buildPackRef(ei.fullParentDir, ei.stat.ino, ei.stat.mtime.getTime())];
        return ei;
      }
      var idx = masterEI_idx[1];
      // wasn't first one so needs slicing
      rtenv.updatedPackRefs[dnv] = masterPackRefs.slice(idx);
      var masterEI = masterEI_idx[0];
      return masterEI;
    });
  }).toPromise(_bluebird2['default']);
}