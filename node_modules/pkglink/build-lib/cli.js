#!/usr/bin/env node
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _fsExtraPromise = require('fs-extra-promise');

var _fsExtraPromise2 = _interopRequireDefault(_fsExtraPromise);

var _numeral = require('numeral');

var _numeral2 = _interopRequireDefault(_numeral);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _rxjs = require('rxjs');

var _singleLineLog = require('single-line-log');

var _singleLineLog2 = _interopRequireDefault(_singleLineLog);

var _stripAnsi = require('strip-ansi');

var _stripAnsi2 = _interopRequireDefault(_stripAnsi);

var _format = require('./util/format');

var _file = require('./util/file');

var _runEnvDefaults = require('./run-env-defaults');

var _runEnvDefaults2 = _interopRequireDefault(_runEnvDefaults);

var _index = require('./index');

var _managed = require('./util/managed');

var _managed2 = _interopRequireDefault(_managed);

var _cliOptions = require('./cli-options');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var isTTY = process.stdout.isTTY; // truthy if in terminal
var singleLineLog = _singleLineLog2['default'].stderr;

var rtenv = _extends({}, _runEnvDefaults2['default']);

var _gatherOptionsConfig = (0, _cliOptions.gatherOptionsConfig)(process.argv.slice(2), displayHelp),
    argv = _gatherOptionsConfig.argv,
    config = _gatherOptionsConfig.config;

// should we be using terminal output


var isTermOut = isTTY && !argv['gen-ln-cmds'];

if (argv.help || !argv._.length && !argv.prune) {
  // display help
  displayHelp();
  process.exit(23);
}

function displayHelp() {
  (0, _file.outputFileStderrSync)(_path2['default'].join(__dirname, '..', 'usage.txt'));
}

_fsExtraPromise2['default'].ensureFileSync(config.refsFile);

var startingDirs = argv._.map(function (x) {
  return _path2['default'].resolve(x);
});

// key=nameVersion value: array of ref tuples [modPath, packJsonInode, packJsonMTimeEpoch]
rtenv.existingPackRefs = _fsExtraPromise2['default'].readJsonSync(config.refsFile, { throws: false }) || {};

rtenv.cancelled$ = new _rxjs.ReplaySubject(1);

var singleLineLog$ = new _rxjs.Subject();
singleLineLog$.filter(function (x) {
  return isTermOut;
}) // only if in terminal
.distinctUntilChanged().throttleTime(100).takeUntil(rtenv.cancelled$).subscribe({
  next: function next(x) {
    return singleLineLog(x);
  },
  complete: function complete() {
    singleLineLog('');
    singleLineLog.clear();
  }
});
var log = singleLineLog$.next.bind(singleLineLog$);
log.clear = function () {
  if (isTermOut) {
    singleLineLog('');
    singleLineLog.clear();
  }
};
rtenv.log = log; // share this logger in the rtenv

function out(str) {
  var s = isTermOut ? str : (0, _stripAnsi2['default'])(str);
  process.stdout.write(s);
  process.stdout.write(_os2['default'].EOL);
}
rtenv.out = out; // share this output fn in the rtenv

var cancel = _ramda2['default'].once(function () {
  rtenv.cancelled = true;
  rtenv.cancelled$.next(true);
  console.error('cancelling...');
});
var finalTasks = _ramda2['default'].once(function () {
  singleLineLog$.complete();
  if (argv.dryrun || argv['gen-ln-cmds']) {
    out('# ' + _chalk2['default'].blue('pkgs:') + ' ' + (0, _numeral2['default'])(rtenv.packageCount).format('0,0') + ' ' + _chalk2['default'].yellow('would save:') + ' ' + _chalk2['default'].bold((0, _format.formatBytes)(rtenv.savedByteCount)));
    _managed2['default'].shutdown();
    return;
  }
  if (argv.prune || Object.keys(rtenv.updatedPackRefs).length) {
    var sortedExistingPackRefs = (0, _format.sortObjKeys)(_ramda2['default'].merge(rtenv.existingPackRefs, rtenv.updatedPackRefs));
    _fsExtraPromise2['default'].outputJsonSync(config.refsFile, sortedExistingPackRefs);
    // if pruned or if no savings, at least let them know refs updated
    if (argv.prune || !rtenv.savedByteCount) {
      out('updated ' + config.refsFile);
    }
  }
  out(_chalk2['default'].blue('pkgs:') + ' ' + (0, _numeral2['default'])(rtenv.packageCount).format('0,0') + ' ' + _chalk2['default'].green('saved:') + ' ' + _chalk2['default'].bold((0, _format.formatBytes)(rtenv.savedByteCount)));
  _managed2['default'].shutdown();
});

_managed2['default'].onInterrupt(cancel); // fires on SIGINT
process.once('SIGTERM', cancel).once('EXIT', finalTasks);

if (argv.verbose) {
  console.log('argv', argv);
  console.log('config', config);
}

out(''); // advance to full line

// Main program start, create task$ and run
var arrTaskObs = [];

function _ref() {
  log('' + _chalk2['default'].bold('pruning...'));
  return (0, _index.prune)(config, rtenv.existingPackRefs);
}

function _ref2(newShares) {
  rtenv.existingPackRefs = newShares;
}

if (argv.prune) {
  arrTaskObs.push(_rxjs.Observable.defer(_ref)['do'](_ref2));
}

function _ref3() {
  return (0, _index.scanAndLink)(config, rtenv, startingDirs);
}

if (startingDirs.length) {
  arrTaskObs.push(_rxjs.Observable.defer(_ref3));
}

// run all the task observables serially

function _error(err) {
  return console.error(err);
}

function _complete() {
  return finalTasks();
}

if (arrTaskObs.length) {
  _rxjs.Observable.concat.apply(_rxjs.Observable, arrTaskObs).subscribe({
    error: _error,
    complete: _complete
  });
}