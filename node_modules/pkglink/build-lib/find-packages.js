'use strict';

exports.__esModule = true;
exports['default'] = findPackages;

var _fsExtraPromise = require('fs-extra-promise');

var _fsExtraPromise2 = _interopRequireDefault(_fsExtraPromise);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _readdirp = require('readdirp');

var _readdirp2 = _interopRequireDefault(_readdirp);

var _rxjs = require('rxjs');

var _format = require('./util/format');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// unix or windows paths
var ENDS_NODE_MOD_RE = /[\\/]node_modules$/;

/*
   Special directory tree filter for finding node_module/X packages
   - no dirs starting with '.'
   - accept node_modules
   - if under ancestor of node_modules
   - allow if parent is node_modules (keep in node_modules/X tree)
   - otherwise allow (not yet found node_modules tree)
 */
function filterDirsNodeModPacks(ei) {
  var eiName = ei.name;
  if (eiName.charAt(0) === '.') {
    return false;
  } // no dot dirs
  if (eiName === 'node_modules') {
    return true;
  } // node_modules
  var eiFullParentDir = ei.fullParentDir;
  if (eiFullParentDir.indexOf('node_modules') !== -1) {
    // under node_modules
    // only if grand parent is node_modules will we continue down
    return _path2['default'].basename(eiFullParentDir) === 'node_modules';
  }
  return true; // not in node_modules yet, so keep walking
}

function _ref2(ei) {
  return ENDS_NODE_MOD_RE.test(_path2['default'].dirname(ei.fullParentDir));
}

function _ref3(ei) {
  return _rxjs.Observable.from(_fsExtraPromise2['default'].readJsonAsync(ei.fullPath, { throws: false }));
}

function _ref4(ei, pack) {
  return { // returns eiDN
    entryInfo: truncEI(ei),
    devNameVer: pack && pack.name && pack.version ? (0, _format.formatDevNameVersion)(ei.stat.dev, pack.name, pack.version) : null
  };
}

function _ref5(obj) {
  return obj.devNameVer;
}

function findPackages(config, rtenv, rootDirs, logUpdate) {
  function _ref() {
    return !rtenv.cancelled;
  }

  // ret obs of eiDN
  return _rxjs.Observable.from(rootDirs)
  // find all package.json files
  .mergeMap(function (startDir) {
    var readdirpOptions = {
      root: startDir,
      entryType: 'files',
      lstat: true, // want actual files not symlinked
      fileFilter: ['package.json'],
      directoryFilter: filterDirsNodeModPacks
    };
    if (config.treeDepth) {
      readdirpOptions.depth = config.treeDepth;
    }
    var fstream = (0, _readdirp2['default'])(readdirpOptions);
    rtenv.cancelled$.subscribe(function () {
      return fstream.destroy();
    }); // stop reading
    return _rxjs.Observable.fromEvent(fstream, 'data').takeWhile(_ref).takeUntil(_rxjs.Observable.fromEvent(fstream, 'close')).takeUntil(_rxjs.Observable.fromEvent(fstream, 'end'));
  }, config.concurrentOps)
  // only parents ending in node_modules
  .filter(_ref2)
  // get name and version from package.json
  .mergeMap(_ref3, _ref4, config.concurrentOps).filter(_ref5) // has name and version, not null
  ['do'](function (obj) {
    rtenv.packageCount += 1;
    rtenv.currentPackageDir = obj.entryInfo.fullParentDir;
  })['do'](function (obj) {
    logUpdate();
  });
}

/*
  Truncate entryInfo to just fullParentDir and stat to save memory
 */
function truncEI(ei) {
  return _ramda2['default'].pick(['fullParentDir', 'stat'], ei);
}