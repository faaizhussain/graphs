'use strict';

exports.__esModule = true;
exports.genModuleLinks = genModuleLinks;
exports.handleModuleLinking = handleModuleLinking;
exports.determineLinks = determineLinks;

var _fsExtraPromise = require('fs-extra-promise');

var _fsExtraPromise2 = _interopRequireDefault(_fsExtraPromise);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readdirp = require('readdirp');

var _readdirp2 = _interopRequireDefault(_readdirp);

var _rxjs = require('rxjs');

var _packRef = require('./pack-ref');

var _linkFilter = require('./link-filter');

var _linkFilter2 = _interopRequireDefault(_linkFilter);

var _log = require('./util/log');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*
 Default hard link function which unlinks orig dst then creates link
 If failed to link (maybe fs doesn't support), recopy from src
 @return promise that resolves on success or rejects on failure
 */
function hardLink(src, dst) {
  function _ref() {
    console.error('INFO: recopied %s to %s to cleanup from link error which follows', src, dst);
  }

  function _ref2(err) {
    console.error('ERROR: was not able to restore %s after link error that follows, reinstall package', dst);
  }

  return _fsExtraPromise2['default'].unlinkAsync(dst).then(function () {
    return _fsExtraPromise2['default'].linkAsync(src, dst);
  })['catch'](function (err) {
    _fsExtraPromise2['default'].copyAsync(src, dst, {
      clobber: false,
      preserveTimestamps: true
    }).then(_ref)['catch'](_ref2);
    throw err; // rethrow original err
  });
}

function genModuleLinks(config, rtenv, lnkModSrcDst) {
  // returns observable
  return determineLinks(config, rtenv, lnkModSrcDst, true)
  // just output the ln commands
  ['do'](function (_ref3) {
    var src = _ref3[0],
        dst = _ref3[1],
        size = _ref3[2];

    rtenv.out('ln -f "' + src + '" "' + dst + '"');
  });
}

function _ref4(s_d_sz, ops) {
  return s_d_sz;
}

function handleModuleLinking(config, rtenv, lnkModSrcDst) {
  // returns observable
  return determineLinks(config, rtenv, lnkModSrcDst, true).mergeMap(function (s_d_sz) {
    return performLink(config, rtenv, s_d_sz);
  }, _ref4, config.concurrentOps);
}

function _ref6(err) {
  if (err.code !== 'ENOENT') {
    console.error(err);
  }
  return null;
}

function _ref7(srcEI, dstEI) {
  return {
    srcEI: srcEI,
    dstEI: dstEI
  };
}

function _ref8(x) {
  return [// s_d_sz
  x.srcEI.fullPath, x.dstEI.fullPath, x.srcEI.stat.size];
}

function determineLinks(config, rtenv, lnkModSrcDst) {
  var updatePackRefs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // returns observable of s_d_sz [srcFullPath, dstFullPath, size]

  var logUpdate = (0, _log.createLogUpdate)(config, rtenv);

  // src is the master we link from, dst is the dst link
  var devNameVer = lnkModSrcDst.devNameVer; // device:nameVersion
  var srcRoot = lnkModSrcDst.src;
  var srcPackInode = lnkModSrcDst.srcPackInode;
  var srcPackMTimeEpoch = lnkModSrcDst.srcPackMTimeEpoch;
  var dstRoot = lnkModSrcDst.dst;
  var dstPackInode = lnkModSrcDst.dstPackInode;
  var dstPackMTimeEpoch = lnkModSrcDst.dstPackMTimeEpoch;

  function _ref5(packRef) {
    return packRef[0] !== dstRoot;
  }

  if (updatePackRefs) {
    var packRefs = rtenv.updatedPackRefs[devNameVer] || [];
    if (!packRefs.length) {
      packRefs.push((0, _packRef.buildPackRef)(srcRoot, srcPackInode, srcPackMTimeEpoch));
    }
    packRefs = packRefs.filter(_ref5);
    if (packRefs.length < config.refSize) {
      packRefs.push((0, _packRef.buildPackRef)(dstRoot, dstPackInode, dstPackMTimeEpoch));
    }
    rtenv.updatedPackRefs[devNameVer] = packRefs;
  }

  var fstream = (0, _readdirp2['default'])({
    root: lnkModSrcDst.src,
    entryType: 'files',
    lstat: true, // want actual files not symlinked
    fileFilter: ['!.*'],
    directoryFilter: ['!.*', '!node_modules']
  });
  fstream.once('end', function () {
    rtenv.completedPackages += 1;
    logUpdate();
  });
  rtenv.cancelled$.subscribe(function () {
    return fstream.destroy();
  }); // stop reading

  return _rxjs.Observable.fromEvent(fstream, 'data').takeWhile(function () {
    return !rtenv.cancelled;
  }).takeUntil(_rxjs.Observable.fromEvent(fstream, 'close')).takeUntil(_rxjs.Observable.fromEvent(fstream, 'end'))
  // combine with stat for dst
  .mergeMap(function (srcEI) {
    var dstPath = _path2['default'].resolve(dstRoot, srcEI.path);
    return _rxjs.Observable.from(_fsExtraPromise2['default'].statAsync(dstPath).then(function (stat) {
      return {
        fullPath: dstPath,
        stat: stat
      };
    })['catch'](_ref6));
  }, _ref7, config.concurrentOps).filter(function (x) {
    return (0, _linkFilter2['default'])(config, dstPackInode, x);
  }).map(_ref8);
}

function performLink(config, rtenv, _ref9) {
  var src = _ref9[0],
      dst = _ref9[1],
      size = _ref9[2];
  // returns observable
  var link = rtenv.linkFn || hardLink; // use custom link if provided
  return _rxjs.Observable.fromPromise(link(src, dst)['catch'](function (err) {
    console.error('ERROR: failed to unlink/link src:' + src + ' dst:' + dst, err);
    throw err;
  }));
}